# Java编程基础
# 基础程序设计
##### 八种基本数据类型
* 整数，没有无符号的整数
> byte 1字节,范围是-128 ～ 127
> 
> short 2字节
> 
> int 4字节，默认
> 
> long 8字节，一般加后缀l/L
* 浮点数
> float 4字节 ，要指定必须加：f/F
> 
> double 8字节，默认，一般加后缀d/D
> 
* 其余类型
> char，字符 不建议使用，建议使用String替代char
> 
> boolean 布尔
##### 进制
> 16进制：0x/0X，开头
> 8进制：0,开头
> 10进制：默认
> 2进制：0b/0B,开头
##### 常量
> final 修饰常量，一次赋值之后不能被更改，常量名一般全大写
> 
> static 修饰的变量能在成员方法和静态方法中使用，成员变量不能在静态方法中使用
##### 运算符
> 
> 绝对值：Math.abs(x)
> 
> 取余数：a % b，a/b的余数
> 
> 两个都是整数，取模，否则就是除法：11/4 =2 ,11/4.0=2.75
> 
> a += b  等于 a = a+b
> 
> 自增：n++(先使用n,然后n再+1) 或者 ++n(先+1,然后再使用n)
> 
> 三元运算符：boolean ? yes的值 ： no的值

# io输入输出流
* linux文件中，每行的结尾都是ASCII=10的换行符，空文件的第一行，也会有一个换行符 
### 字节为单位的输入输出流，基础接口是InputStream和OutputStream
*  为什么字节流不能指定输入输出的编码？因为本身就是字节为单位，而编码是一个字符不同的字节数来表示，所以只有字符流的输入输出才能指定字符集
> FileInputStream，OutputStream,读取磁盘文件的输入输出流,输出流可以指定是删除旧文件或者追加的方式。
> 
> read()，读入一个字节，遇到文件尾时返回-1
_>> 为啥读的字节打印出来是0～255,不是说字节的范围是-128～127吗？这是因为它转换成了对应的无符号整数，但是读入到字节数组中时，对应的无符号整数又会回归原本的有符号整数,比如读入中文的第一个字节，加入233,直接sout就是233,但是读入到字节数组中就回归成原本的-23
> 此外，读到文件尾需要有个判定标志，所以只能返回无符号整数。不然负数不能作为结束标志
> 
> read(byte[] a),将字节读入到数组中
> 
> write(),写出一个字节到输出流
> 
> write(byte[] a)，将字节数组写到输出流
> 
> read和write在执行时会阻塞，直到字节被读入或者写出，如果流不能被访问，那么当前线程将阻塞，但是在流变得可用的这段时间，线程可以去做其他的事。
* DataInputStream,DataOutputStream， 读取不同长度的字节赋给基本数据类型或者将基本数据类型写到流中（而不用先将其转换为字节后在write）,
> readInt,可以读入4个字节给int的变量,
> 
> readLong,可以读入8个字节给long的变量
> 
* PushBackInputStream(没有相应的输出流)，可回推输入流，如果字节不是想要的，甚至是不用先read,可以直接往输入流的头部中加字节的（一般只能往输出流中写如字节），但是关闭后新加的字节并不会写到文件中，因为只是输入流
* BufferedInputStream,bufferedOutputStream,带缓冲区的输入输出流
* flush()，手动写输出流到文件中,注意，不是说程序执行完了，会自动推送输出流中的数据到文件中，因为电脑也有缓冲区

# 字符流 Reader，Writer,所有原生的read和write都对应成了Unicode码元
> 构造器一定要指定字符集，尽管默认的UTF-8,但是一旦不一致，那么显示的就不是你在文本中所见的内容，输入流指定字符集表示将文件的字节流转换为指定的编码的字节流，

> 输出流指定字符集表示字节流转换为指定的字符集的字节流输出,但是如果是追加的方式，字节流编码和原文件的编码方式不一致，可能出现乱码

> 文本输出：PrintStream,用print方法输出文本
> 

















# 并发
##### 创建线程类
> 继承Thread类，并覆盖：run()方法
> 
> 实现Runnable接口，并覆盖：run()方法
> 
> 启动线程必须要执行start方法，否则不会创建新线程执行
